namespace Typesetting {

    namespace Component {

        class Code(opts_, code_) : Component.Base(opts_) {
            var endtag_, theme_;
            private initialize() {
                if (code_.isUndefined) {
                    [code_, opts_] = [opts_];
                }
            }
            public showBox(type) {
                opts_.box = type ?? Typesetting.BOX_NORMAL;
            }
            public showLineNumber(tf) {
                opts_.lineNumber = tf ?? true;
            }
            public setColor(color) {
                opts_.color = color;
            }
            public setBackgroundColor(bgcolor) {
                opts_.bgcolor = bgcolor;
            }
            public setSyntax(lang) {
                opts_.lang = lang;
                opts_.syntax = Typesetting.Style.Code[lang || '-'];
            }
            private analyzeColor(words, text, { name, pattern, color }, start, end) {
                var pos = 0;
                pattern.reset(text);
                while (pattern.find()) {
                    var b, e, g = pattern.group;
                    for (var i = 1, l = g.length(); i < l; ++i) {
                        var gi = g[i];
                        b = g[i].begin;
                        e = g[i].end;
                        if (pos < b) {
                            words.push({
                                name: "none",
                                word: text.subString(pos, b - pos),
                                color: color[0],
                                pos: { start: start+pos, end: start+b },
                            });
                        }
                        words.push({
                            name: name,
                            word: text.subString(b, e - b),
                            color: color[i],
                            pos: { start: start+b, end: start+e },
                        });
                        pos = e;
                    }
                }
                var e = end - start;
                if (pos < e) {
                    words.push({
                        name: "none",
                        word: text.subString(pos, e - pos),
                        color: color[0],
                        pos: { start: start+pos, end: start+e },
                    });
                }
            }
            private writeLineWithColor(line, fontObj, fontSize, info, context, core, writer, lineFeedWidth) {
                var startPos = 0;
                var words = [];
                if (endtag_.pattern.isRegex) {
                    var p = endtag_.pattern;
                    p.reset(line);
                    p.setPosition(0);
                    if (!p.find()) {
                        var color = context.font.color;
                        context.font.color = endtag_.color;
                        core.util.writeLine(opts_, line, fontObj, fontSize, lineFeedWidth);
                        context.font.color = color;
                        return;
                    }
                    var g = p.group[0];
                    if (0 < g.begin) {
                        words.push({
                            name: "none",
                            word: line.subString(0, g.begin),
                            pos: { start: 0, end: g.begin },
                        });
                    }
                    words.push({
                        name: endtag_.name,
                        word: g.string,
                        color: endtag_.color,
                        pos: { start: g.begin, end: g.end },
                    });
                    startPos = g.end;
                    endtag_ = null;
                }

                var buf = { start: startPos, end: startPos };
                var pats = opts_.syntax.pattern;
                var pl = pats.length();
                for (var pos = startPos, len = line.length(); pos < len; ) {
                    var start = pos;
                    for (var i = 0; i < pl; ++i) {
                        var pi = pats[i];
                        if (pi.position.isDefined && pi.position != pos) {
                            continue;
                        }
                        var p = pi.pattern;
                        p.reset(line);
                        p.setPosition(pos);
                        if (p.find() && (found = p.group[0]).begin == pos) {
                            if (buf.start != buf.end) {
                                words.push({
                                    name: "none",
                                    word: line.subString(buf.start, buf.end - buf.start),
                                    pos: { start: buf.start, end: buf.end },
                                });
                            }
                            var color = pi.color ?? theme_[pi.name];
                            if (color.isArray) {
                                var group = p.group;
                                var ps = color.map { => [group[_2].begin, group[_2].end] };
                                var s = found.begin;
                                for (var j = 1, jl = ps.length(); j < jl; ++j) {
                                    var pss = ps[j][0];
                                    var pse = ps[j][1];
                                    if (s < pss) {
                                        words.push({
                                            name: pi.name,
                                            word: line.subString(s, pss - s),
                                            color: color[0],
                                            pos: { start: s, end: pss },
                                            bold: pi.bold,
                                        });
                                    }
                                    if (color[j].isObject) {
                                        analyzeColor(words, line.subString(pss, pse - pss), color[j], pss, pse);
                                    } else {
                                        words.push({
                                            name: pi.name,
                                            word: line.subString(pss, pse - pss),
                                            color: color[j],
                                            pos: { start: pss, end: pse },
                                            bold: pi.bold,
                                        });
                                    }
                                    s = pse;
                                }
                                if (s < found.end) {
                                    words.push({
                                        name: pi.name,
                                        word: line.subString(s, found.end - s),
                                        color: color[0],
                                        pos: { start: s, end: found.end },
                                        bold: pi.bold,
                                    });
                                }
                            } else {
                                words.push({
                                    name: pi.name,
                                    word: line.subString(found.begin, found.end - found.begin),
                                    color: color,
                                    pos: { start: found.begin, end: found.end },
                                    bold: pi.bold,
                                });
                            }
                            if (pi.end.isRegex) {
                                endtag_ = { pattern: pi.end, color: color, name: pi.name };
                                pos = len;
                            } else if (pi.end.group.isInteger) {
                                endtag_ = { pattern: new Regex(p.group[pi.end.group].string), color: color, name: pi.name };
                                pos = len;
                            } else {
                                pos = found.end;
                                buf.start = buf.end = found.end;
                            }
                            break;
                        }
                    }
                    if (pos == start) {
                        buf.end = ++pos;
                    }
                }
                if (buf.start != buf.end) {
                    words.push({
                        name: "none",
                        word: line.subString(buf.start, buf.end - buf.start),
                    });
                }

                var x = opts_.margin.left;
                words.each { &({ word, color, bold })
                    var fgColor, fontObjPrev;
                    fgColor = context.font.color;
                    if (bold) {
                        fontObjPrev = fontObj;
                        fontObj = context.font.fontObjBase.bold;
                    }

                    context.font.color = Typesetting.Util.parseColor(color) if (color.isDefined);
                    var textWidth = info.measure.textWidth(fontObj, fontSize, word);
                    var n = Typesetting.Linebreak.Box(textWidth, new Typesetting.Word(info).setWord(fontObj, fontSize, word));
                    writer.write(n, x);
                    x += textWidth;

                    if (bold) {
                        fontObj = fontObjPrev;
                    }
                    context.font.color = fgColor;
                };
                writer.lineBreak(lineFeedWidth);
            }
            public write(info, context, core) {
                core.flushParagraph();
                if (opts_.lang.isDefined && opts_.syntax.isUndefined) {
                    info.logger.warn("Unknown code language: " + opts_.lang);
                }
                theme_ = Typesetting.Style.CodeColor[opts_.syntax.theme ?? Typesetting.Style.CodeColorTheme ?? '-']
                        ?? { box: Typesetting.BOX_SHADOW, lineNumber: true };
                var lineColor = context.code.lineColor ?? info.base.code.lineColor;
                var fgColor = opts_.color ?? opts_.syntax.foregroundColor ?? theme_["foreground-color"];
                var bgColor = opts_.bgcolor ?? opts_.syntax.backgroundColor ?? theme_["background-color"]
                                ?? context.code.backgroundColor ?? info.base.code.backgroundColor;
                var shadowColor = context.code.shadowColor ?? info.base.code.shadowColor;

                [opts_, code_] = core.util.makeOption(opts_, code_, false);
                var fontBgColor = context.font.bgcolor;
                var fontColor = context.font.color;
                var fontObj = context.font.fontObj;
                var fontObjBase = context.font.fontObjBase;
                core.fontType("Monotype");
                context.font.color = fgColor;
                context.font.bgcolor = bgColor;

                var writer = info.writer;
                var margin = writer.getMargin();
                var numberSize = info.base.code.numberSize;
                var codeFontSize = info.base.code.fontSize;
                var lineFeedWidthBase = codeFontSize * 1.3;
                var texts = code_.trim().split(/\r?\n/);

                var chklines = (texts.length() >= 2) ? 4 : (texts.length() + 2);
                var lb = writer.getPos().y - lineFeedWidthBase * chklines - info.base.code.padding * 2;
                if (0 < lb && lb <= writer.getYBottom()) {
                    writer.pageBreak();
                }

                var lineNumber = opts_.lineNumber ?? opts_.syntax.lineNumber ?? theme_.lineNumber ?? true;
                const shadowWidth = 3;
                var base = margin.left + info.base.code.margin.left + shadowWidth + 1;
                var lbase = base;
                var rbase = margin.right + info.base.code.margin.right - shadowWidth - 1;
                if (lineNumber) {
                    var width = info.measure.textWidth(context.font.fontObj, numberSize, "999999");
                    opts_.margin.right = rbase;
                    opts_.margin.left = lbase + width;
                    lbase = opts_.margin.left - info.base.code.labelsep;
                } else {
                    opts_.margin.left = lbase;
                    opts_.margin.right = rbase;
                }
                var boxtype = opts_.box ?? opts_.syntax.box ?? theme_.box ?? Typesetting.BOX_SHADOW;
                var shadow = boxtype[1] == 0x01;
                var pageMargin = writer.makeMarginSize();
                var left = base - info.base.code.padding;
                var right = (pageMargin.pageWidth - opts_.margin.right) + (shadow ? 0 : 2);
                var linetop1 = writer.getLineTop(context.font.fontObj, codeFontSize);
                var lineprev = linetop1;
                var lineWidth = boxtype.isArray ? boxtype[0] : boxtype;
                var linelength = right - left;
                if (lineWidth > 0) {
                    var height = info.base.code.padding;
                    writer.drawBox(left, lineprev, linelength, height+lineWidth*2+1+lineFeedWidthBase, lineWidth, bgColor, bgColor);
                    writer.drawLine(left, linetop1, linelength, 0, lineWidth, lineColor);
                    writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor);
                    writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor);
                    if (shadow) {
                        writer.drawLine(right+2, lineprev-2, 0, height+1, shadowWidth, shadowColor, -1);
                    }
                    writer.updateY();
                    var lb = writer.getPos().y;
                    writer.setY(lb - info.base.code.padding);
                    lineprev -= info.base.code.padding;
                }

                var ybottom = writer.getYBottom();
                var isTop = false;
                var tlast = texts.length() - 1;
                texts.each { &(line, i)
                    if (isTop) {
                        var height = i == tlast ? (lineFeedWidthBase + info.base.code.padding - lineWidth * 2 - 2) : (lineFeedWidthBase * 2);
                        writer.drawBox(left, lineprev, linelength, height + lineFeedWidthBase, lineWidth, bgColor, bgColor);
                        writer.setY(lineprev - height);
                    } else {
                        var lb = writer.getPos().y;
                        writer.drawBox(left, lb, linelength, lineFeedWidthBase, lineWidth, bgColor, bgColor);
                    }

                    if (lineNumber) {
                        var num = "" + (i+1);
                        var x = lbase - info.measure.textWidth(fontObj, numberSize, num);
                        core.util.writeX(x, num, fontObj, numberSize);
                    }

                    if (opts_.syntax.isUndefined || opts_.syntax.pattern.isUndefined) {
                        core.util.writeLine(opts_, line, context.font.fontObj, codeFontSize, lineFeedWidthBase);
                    } else {
                        writeLineWithColor(line, context.font.fontObj, codeFontSize, info, context, core, writer, lineFeedWidthBase);
                    }

                    var isBreak = writer.getPos(true).y <= ybottom;
                    if (!isBreak) {
                        linetop1 = writer.getLineTop(context.font.fontObj, context.font.codeFontSize);
                        var height = lineprev - linetop1;
                        writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor);
                        writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor);
                        if (shadow) {
                            var top = isTop ? lineprev : (lineprev-2);
                            var height2 = isTop ? (height+5) : (height+3);
                            writer.drawLine(right+2, top, 0, height2, shadowWidth, shadowColor);
                        }
                        lineprev = linetop1;
                        isTop = false;
                    } else {
                        if (i == tlast) {
                            var height = lineFeedWidthBase + 2;
                            writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor, -1);
                            writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor, -1);
                            if (shadow) {
                                writer.drawLine(right+2, lineprev-2, 0, height+1, shadowWidth, shadowColor, -1);
                            }
                            var top = lineprev - height;
                            writer.drawLine(left, top, linelength, 0, lineWidth, lineColor, -1);
                            if (shadow) {
                                writer.drawLine(left+2, top-2, linelength+1, 0, shadowWidth, shadowColor, -1);
                            }
                            lineWidth = 0;  # no more drawing a line.
                        } else {
                            var height = lineFeedWidthBase;
                            writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor, -1);
                            writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor, -1);
                            if (shadow) {
                                writer.drawLine(right+2, lineprev-2, 0, height-2, shadowWidth, shadowColor, -1);
                            }
                            lineprev = pageMargin.pageHeight - margin.top;
                            isTop = true;
                        }
                        ybottom = writer.getYBottom();
                    }
                };

                if (lineWidth > 0) {
                    writer.addY(lineFeedWidthBase);
                    var linetop2 = writer.getLineTop(context.font.fontObj, codeFontSize);
                    var height = lineprev - linetop2;
                    writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor);
                    writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor);
                    writer.drawLine(left, linetop2, linelength, 0, lineWidth, lineColor);
                    if (shadow) {
                        writer.drawLine(left+2, linetop2-2, linelength+1, 0, shadowWidth, shadowColor);
                    }
                }
                writer.addY(lineFeedWidthBase);

                context.font.fontObjBase = fontObjBase;
                context.font.fontObj = fontObj;
                context.font.color = fontColor;
                context.font.bgcolor = fontBgColor;
                if (info.base.resetIndentAfterNonParagraph) {
                    context.notParagraph = info.base.noIndentTopOfParagraph;
                }
            }
        }

    } # namespace Component

} # namespace Typesetting
