namespace Typesetting {

    namespace Component {

        class Code(opts_, code_) : Component.Base(opts_) {
            var endtag_;
            private initialize() {
                if (code_.isUndefined) {
                    [code_, opts_] = [opts_];
                }
            }
            public showBox(type) {
                opts_.box = type ?? Typesetting.BOX_NORMAL;
            }
            public showLineNumber(tf) {
                opts_.lineNumber = tf ?? true;
            }
            public setColor(color) {
                opts_.color = color;
            }
            public setBackgroundColor(bgcolor) {
                opts_.bgcolor = bgcolor;
            }
            public setSyntax(lang) {
                opts_.lang = lang;
                opts_.syntax = Typesetting.Style.Code[lang];
            }
            private writeLineWithColor(line, fontObj, fontSize, info, context, core, writer, lineFeedWidth) {
                var startPos = 0;
                var words = [];
                if (endtag_.pattern.isRegex) {
                    var p = endtag_.pattern;
                    p.reset(line);
                    p.setPosition(0);
                    if (!p.find()) {
                        var color = context.font.color;
                        context.font.color = endtag_.color;
                        core.util.writeLine(opts_, line, fontObj, fontSize, lineFeedWidth);
                        context.font.color = color;
                        return;
                    }
                    var g = p.group[0];
                    words.push({
                        name: endtag_.name,
                        word: g.string,
                        color: endtag_.color,
                        pos: { start: g.begin, end: g.end },
                    });
                    startPos = g.end;
                    endtag_ = null;
                }

                var buf = { start: startPos, end: startPos };
                var pats = opts_.syntax.pattern;
                var pl = pats.length();
                for (var pos = startPos, len = line.length(); pos < len; ) {
                    var start = pos;
                    for (var i = 0; i < pl; ++i) {
                        var pi = pats[i];
                        var p = pi.pattern;
                        p.reset(line);
                        p.setPosition(pos);
                        if (p.find() && (found = p.group[0]).begin == pos) {
                            if (buf.start != buf.end) {
                                words.push({
                                    name: "none",
                                    word: line.subString(buf.start, buf.end - buf.start),
                                    pos: { start: buf.start, end: buf.end },
                                });
                            }
                            words.push({
                                name: pi.name,
                                word: line.subString(found.begin, found.end - found.begin),
                                color: pi.color,
                                pos: { start: found.begin, end: found.end },
                            });
                            if (pi.end.isRegex) {
                                endtag_ = { pattern: pi.end, color: pi.color, name: pi.name };
                                pos = len;
                            } else {
                                pos = found.end;
                                buf.start = buf.end = found.end;
                            }
                            break;
                        }
                    }
                    if (pos == start) {
                        buf.end = ++pos;
                    }
                }
                if (buf.start != buf.end) {
                    words.push({
                        name: "none",
                        word: line.subString(buf.start, buf.end - buf.start),
                    });
                }

                var x = opts_.margin.left;
                words.each { &({ word, color })
                    var fgColor = context.font.color;
                    context.font.color = Typesetting.Util.parseColor(color) if (color.isDefined);
                    var textWidth = info.measure.textWidth(fontObj, fontSize, word);
                    var n = Typesetting.Linebreak.Box(textWidth, new Typesetting.Word(info).setWord(fontObj, fontSize, word));
                    writer.write(n, x);
                    x += textWidth;
                    context.font.color = fgColor;
                };
                writer.lineBreak(lineFeedWidth);
            }
            public write(info, context, core) {
                core.flushParagraph();
                if (opts_.lang.isDefined && opts_.syntax.isUndefined) {
                    info.logger.warn("Unknown code language: " + opts_.lang);
                }
                var lineColor = context.code.lineColor ?? info.base.code.lineColor;
                var fgColor = opts_.color ?? opts_.syntax.foregroundColor;
                var bgColor = opts_.bgcolor ?? opts_.syntax.backgroundColor ?? context.code.backgroundColor ?? info.base.code.backgroundColor;
                var shadowColor = context.code.shadowColor ?? info.base.code.shadowColor;

                [opts_, code_] = core.util.makeOption(opts_, code_, false);
                var fontBgColor = context.font.bgcolor;
                var fontColor = context.font.color;
                var fontObj = context.font.fontObj;
                var fontObjBase = context.font.fontObjBase;
                core.fontType("Monotype");
                context.font.color = fgColor;
                context.font.bgcolor = bgColor;

                var writer = info.writer;
                var margin = writer.getMargin();
                var numberSize = info.base.code.numberSize;
                var codeFontSize = info.base.code.fontSize;

                const shadowWidth = 3;
                var base = margin.left + info.base.code.margin.left + shadowWidth + 1;
                var lbase = base;
                var rbase = margin.right + info.base.code.margin.right - shadowWidth - 1;
                if (opts_.lineNumber) {
                    var width = info.measure.textWidth(context.font.fontObj, numberSize, "999999");
                    opts_.margin.right = rbase;
                    opts_.margin.left = lbase + width;
                    lbase = opts_.margin.left - info.base.code.labelsep;
                } else {
                    opts_.margin.left = lbase;
                    opts_.margin.right = rbase;
                }
                var shadow = opts_.box[1] == 0x01;
                var lineFeedWidthBase = codeFontSize * 1.3;
                var pageMargin = writer.makeMarginSize();
                var left = base - info.base.code.padding;
                var right = (pageMargin.pageWidth - opts_.margin.right) + (shadow ? 0 : 2);
                var linetop1 = writer.getLineTop(context.font.fontObj, codeFontSize);
                var lineprev = linetop1;
                var lineWidth = opts_.box.isArray ? opts_.box[0] : opts_.box;
                var linelength = right - left;
                if (lineWidth > 0) {
                    var height = info.base.code.padding;
                    writer.drawBox(left, lineprev, linelength, height+lineWidth*2+1+lineFeedWidthBase, lineWidth, bgColor, bgColor);
                    writer.drawLine(left, linetop1, linelength, 0, lineWidth, lineColor);
                    writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor);
                    writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor);
                    if (shadow) {
                        writer.drawLine(right+2, lineprev-2, 0, height+1, shadowWidth, shadowColor, -1);
                    }
                    writer.updateY();
                    var lb = writer.getPos().y;
                    writer.setY(lb - info.base.code.padding);
                    lineprev -= info.base.code.padding;
                }

                var isTop = false;
                var texts = code_.trim().split(/\r?\n/);
                var tlast = texts.length() - 1;
                texts.each { &(line, i)
                    if (isTop) {
                        var height = i == tlast ? (lineFeedWidthBase + info.base.code.padding - lineWidth * 2 - 2) : (lineFeedWidthBase * 2);
                        writer.drawBox(left, lineprev, linelength, height + lineFeedWidthBase, lineWidth, bgColor, bgColor);
                        writer.setY(lineprev - height);
                    } else {
                        var lb = writer.getPos().y;
                        writer.drawBox(left, lb, linelength, lineFeedWidthBase, lineWidth, bgColor, bgColor);
                    }

                    if (opts_.lineNumber) {
                        var num = "" + (i+1);
                        var x = lbase - info.measure.textWidth(fontObj, numberSize, num);
                        core.util.writeX(x, num, fontObj, numberSize);
                    }

                    if (opts_.syntax.isUndefined) {
                        core.util.writeLine(opts_, line, context.font.fontObj, codeFontSize, lineFeedWidthBase);
                    } else {
                        writeLineWithColor(line, context.font.fontObj, codeFontSize, info, context, core, writer, lineFeedWidthBase);
                    }

                    var isBreak = writer.getPos(true).y < 0;
                    if (!isBreak) {
                        linetop1 = writer.getLineTop(context.font.fontObj, context.font.codeFontSize);
                        var height = lineprev - linetop1;
                        writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor);
                        writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor);
                        if (shadow) {
                            var top = isTop ? lineprev : (lineprev-2);
                            var height2 = isTop ? (height+5) : (height+3);
                            writer.drawLine(right+2, top, 0, height2, shadowWidth, shadowColor);
                        }
                        lineprev = linetop1;
                        isTop = false;
                    } else {
                        if (i == tlast) {
                            var height = lineFeedWidthBase + 2;
                            writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor, -1);
                            writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor, -1);
                            if (shadow) {
                                writer.drawLine(right+2, lineprev-2, 0, height+1, shadowWidth, shadowColor, -1);
                            }
                            var top = lineprev - height;
                            writer.drawLine(left, top, linelength, 0, lineWidth, lineColor, -1);
                            if (shadow) {
                                writer.drawLine(left+2, top-2, linelength+1, 0, shadowWidth, shadowColor, -1);
                            }
                            lineWidth = 0;  # no more drawing a line.
                        } else {
                            var height = lineFeedWidthBase;
                            writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor, -1);
                            writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor, -1);
                            if (shadow) {
                                writer.drawLine(right+2, lineprev-2, 0, height-2, shadowWidth, shadowColor, -1);
                            }
                            lineprev = pageMargin.pageHeight - margin.top;
                            isTop = true;
                        }
                    }
                };

                if (lineWidth > 0) {
                    writer.addY(lineFeedWidthBase);
                    var linetop2 = writer.getLineTop(context.font.fontObj, codeFontSize);
                    var height = lineprev - linetop2;
                    writer.drawLine(left, lineprev, 0, height, lineWidth, lineColor);
                    writer.drawLine(right, lineprev, 0, height, lineWidth, lineColor);
                    writer.drawLine(left, linetop2, linelength, 0, lineWidth, lineColor);
                    if (shadow) {
                        writer.drawLine(left+2, linetop2-2, linelength+1, 0, shadowWidth, shadowColor);
                    }
                }
                writer.addY(lineFeedWidthBase);

                context.font.fontObjBase = fontObjBase;
                context.font.fontObj = fontObj;
                context.font.color = fontColor;
                context.font.bgcolor = fontBgColor;
                if (info.base.resetIndentAfterNonParagraph) {
                    context.notParagraph = info.base.noIndentTopOfParagraph;
                }
            }
        }

    } # namespace Component

} # namespace Typesetting
