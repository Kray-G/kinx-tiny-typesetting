namespace Typesetting {

    const TOO_BIG_SPACE = 6553600.0;
    var Linebreak = Typesetting.Linebreak;

    namespace ProcessDoc {

        const lineWidthBase = 0.4;

        class Table(info_, context_, util_, paragraph_) {

            var pos_, margin_, width_, top_, left_;
            var savedPos_, savedMargin_;
            var bottom_, align_, valign_, bgColor_, header_;
            var offsetY_ = 0;
            var limitWidthBase_ = 50;
            var limitWidthDefault_ = limitWidthBase_;
            var limitWidth_ = [];

            private getPrevLine(body, s) {
                for (var i = s - 1; 0 <= i; --i) {
                    if (!body[i].isTableHLine) {
                        return body[i];
                    }
                }
                return null;
            }

            private getNextLine(body, s, l) {
                for (var i = s + 1; i <= l; ++i) {
                    if (!body[i].isTableHLine) {
                        return body[i];
                    }
                }
                return null;
            }

            private adjustWidth(lens, sorted) {
                var l = sorted.length() - 1;
                for (var i = 0; i < l; ++i) {
                    var li = lens[sorted[i].index];
                    var ln = lens[sorted[i+1].index];
                    if (0 < li && (li * 2) < ln) {
                        for (var j = i+1; j <= l; ++j) {
                            var e = sorted[j];
                            lens[e.index] = lens[e.index] * 5 / 8;
                        }
                        return true;
                    }
                }
                return false;
            }

            private checkWidth(lens, widthlist, texts) {
                var sorted = lens.map { => ({ index: _2, len: _1, limit: limitWidth_[_2], width: widthlist[_2], text: texts[_2] }) }.sort { => _1.len <=> _2.len };
                var l = sorted.length();
                for (var i = 0; i < l; ++i) {
                    var e = sorted[i];
                    if (0 < e.width.width && e.width.width < (e.limit ?? limitWidthDefault_)) {
                        if (adjustWidth(lens, sorted)) {
                            return false;
                        }
                        return true;    # no more check.
                    }
                }
                return true;
            }

            private measureText(text, isHeader) {
                if (!text) {
                    return 0.0;
                }
                var lines = paragraph_.exec({ measureWidth: true }, isHeader ? "\\bold{%{text}}" : text);
                var candidate = 0.0;
                var width = 0.0;
                var nodes = lines[0].nodes;
                var len = nodes.length();
                for (var i = 0; i < len; ++i) {
                    var n = nodes[i];
                    if (n.isPenalty && n.penalty == -Linebreak.Infinity) {
                        if (candidate < width) {
                            candidate = width;
                        }
                        width = 0.0;
                    } else if (n.isBox) {
                        width += n.width;
                    } else if (n.isGlue && n.width < 20.0) {
                        width += n.width;
                    }
                }
                return candidate < width ? width : candidate;
            }

            private getLongestLen(b, isHeader) {
                var len = 0;
                b.split(/\n\n|<br\s*\/>/).each {
                    var l = measureText(_1, isHeader);
                    if (len < l) {
                        len = l;
                    }
                };
                return len;
            }

            private setupTable(table) {
                var sizeX = table.size || 1.0;
                var talign = table.align || "c";
                width_ = margin_.width * sizeX;
                left_ = margin_.left;
                if (talign == "c") {
                    left_ += (margin_.width - width_) / 2;
                } else if (talign == "r") {
                    left_ += margin_.width - width_;
                }

                valign_ = table.cellVAlign || "top";
                bgColor_ = table.bgColor;
                var alignPos = 0;
                var align = table.cellAlign;
                var lastLines = align.match(/\|+$/)[0];
                var lastLineCount = lastLines ? lastLines.length() : 0;
                if (lastLineCount > 0) {
                    align = align.subString(0, align.length() - lastLineCount);
                }
                var al = align.length();
                for (var i = 0; i < al; ++i) {
                    if (align[i] == '|'[0]) {
                        align_[alignPos] ??= {};
                        if (align_[alignPos].left) {
                            ++align_[alignPos].lcount;
                        } else {
                            align_[alignPos].left = true;
                            align_[alignPos].lcount = 1;
                        }
                    } else {
                        align_[alignPos] ??= {};
                        align_[alignPos].align = align[i];
                        ++alignPos;
                    }
                }
                if (alignPos > 0 && lastLineCount > 0) {
                    align_[-1].right = true;
                    align_[-1].rcount = lastLineCount;
                }

                var hpos = 0;
                var lens = [];
                var texts = [];
                var body = table.body;
                for (var i = 0, l = body.length(); i < l; ++i) {
                    var ba = body[i];
                    if (ba.isString && ba == "---") {
                        body[i] = { isTableHLine: true };
                    } else if (ba.isString && ba == "===") {
                        body[i] = { isTableHLine: true, count: 2 };
                    } else if (ba.isArray) {
                        if (hpos == table.header) {
                            header_ = ba;
                            header_.isHeader = true;
                            header_.index = i;
                        }
                        ++hpos;
                        var m = ba.length();
                        var mlast = m - 1;
                        for (var j = 0; j < m; ++j) {
                            var b = ba[j];
                            var nextcolspan = j < mlast && ba[j+1] == "<.";
                            var colspan = j > 0 && b == "<.";
                            var rowspan = (i > 0 && b == "^.") || (colspan && ba[j-1].rowspan);
                            if (!colspan && rowspan && getPrevLine(body, i)[j].colspan) {
                                colspan = true;
                            }
                            if (colspan || rowspan) {
                                b = "";
                            }
                            var halign = null, valign = null, changed = true;
                            do {
                                switch (b.subString(0, 2)) {
                                when "l.": halign = "left";   b = b.subString(2).trimLeft();
                                when "c.": halign = "center"; b = b.subString(2).trimLeft();
                                when "r.": halign = "right";  b = b.subString(2).trimLeft();
                                when "t.": valign = "top";    b = b.subString(2).trimLeft();
                                when "m.": valign = "middle"; b = b.subString(2).trimLeft();
                                when "b.": valign = "bottom"; b = b.subString(2).trimLeft();
                                when "w.":
                                    if (limitWidth_[j].isUndefined) {
                                        limitWidth_[j] = limitWidthDefault_;
                                    }
                                    b = b.subString(2).trimLeft();
                                otherwise:
                                    changed = false;
                                }
                            } while (changed);
                            var w = rowspan ? lens[j] : getLongestLen(b, ba.isHeader);
                            if (limitWidth_[j].isDefined && limitWidth_[j] < w) {
                                limitWidth_[j] = w;
                            }
                            if (table.limitColumn.isDefined && j == table.limitColumn) {
                                if (limitWidthDefault_ < w) {
                                    limitWidthDefault_ = w;
                                }
                            }
                            ba[j] = { text: b, width: w, colspan, rowspan, valign, halign, attrs: table.attrs[i][j] };
                            if (!colspan && !nextcolspan && lens[j] < w) {
                                lens[j] = w;
                                texts[j] = {
                                    text: b,
                                    width: w,
                                };
                            }
                        }
                    }
                }
                for (var i = 0, l = lens.length(); i < l; ++i) {
                    if (lens[i] < limitWidthDefault_) {
                        lens[i] = limitWidthDefault_;
                    }
                }
                var widthlist;
                for (var i = 0; i < 10; ++i) {
                    var total = 0;
                    for (var i = 0, l = lens.length(); i < l; ++i) {
                        total += lens[i];
                    }
                    var width = 0;
                    var ratio = System.try({ => width_ / total }).else();
                    if (ratio.isUndefined) break;
                    widthlist = lens.map {
                        var w = _1 * ratio;
                        width += w;
                        return {
                            len: _1,
                            width: w,
                            areaWidth: w - info_.base.table.cellPadding * 2,
                        };
                    };
                    if (checkWidth(lens, widthlist, texts)) {
                        break;
                    }
                }

                return widthlist;
            }

            private makeLines(table, widthlist) {
                top_ = null;
                var rowadjst = [];
                var rowbase = [];
                var totalLineFeedWidth = 0;
                var cellPadding = info_.base.table.cellPadding;
                var cellPadding2 = cellPadding * 2;
                var y = pos_.y - cellPadding * 2;
                for (var i = 0, l = table.body.length(); i < l; ++i) {
                    var ba = table.body[i];
                    var isNextline = table.body[i+1].isTableHLine;
                    if (!ba.isTableHLine) {
                        var nextLine = getNextLine(table.body, i, l-1);
                        totalLineFeedWidth = 0;
                        ba.y = y;
                        var isHeader = ba.isHeader;
                        var lineFeedWidth = 0;
                        var additional = (isNextline ? cellPadding2 : cellPadding);
                        ba[0].areaWidth = widthlist[0].areaWidth;
                        ba[0].width = widthlist[0].width;
                        ba[0].colSpanCount = 1;
                        var prev = ba[0];
                        for (var j = 1, m = ba.length(); j < m; ++j) {
                            var b = ba[j];
                            b.colSpanCount = 1;
                            if (b.colspan) {
                                prev.areaWidth += widthlist[j].areaWidth + info_.base.table.cellPadding * 2;
                                prev.width += widthlist[j].width;
                                prev.colSpanCount++;
                                b.areaWidth = 0;
                                b.width = 0;
                            } else {
                                b.areaWidth = widthlist[j].areaWidth;
                                b.width = widthlist[j].width;
                                prev = b;
                            }
                        }
                        for (var j = 0, m = ba.length(); j < m; ++j) {
                            var b = ba[j];
                            var noIndent = context_.noIndent;
                            context_.noIndent = true;
                            b.lines = paragraph_.exec({ areaWidth: b.areaWidth }, isHeader ? "\\bold{%{b.text}}" : b.text);
                            context_.noIndent = noIndent;
                            b.totalLineFeedWidth = b.lines[0].totalLineFeedWidth + additional;
                            b.y = y + cellPadding + b.lines[0].diffHeight;
                            if (!nextLine[j].rowspan && totalLineFeedWidth < b.totalLineFeedWidth) {
                                totalLineFeedWidth = b.totalLineFeedWidth;
                            }
                            if (!b.rowspan && nextLine[j].rowspan) {
                                rowadjst[j] = b.totalLineFeedWidth;
                                rowbase[j] = { b, ba };
                                b.spanHeight = 0;
                            }
                            if (lineFeedWidth < b.lines[0].lineFeedWidth) {
                                lineFeedWidth = b.lines[0].lineFeedWidth;
                            }
                        }
                        for (var j = 0, m = ba.length(); j < m; ++j) {
                            if (nextLine[j].rowspan) {
                                rowadjst[j] -= totalLineFeedWidth;
                                rowbase[j].b.spanHeight += totalLineFeedWidth;
                            } else {
                                if (totalLineFeedWidth < rowadjst[j]) {
                                    totalLineFeedWidth = rowadjst[j];
                                }
                                rowadjst[j] = 0;
                                rowbase[j].b.spanHeight += totalLineFeedWidth;
                                if (rowbase[j].ba.spanHeight < rowbase[j].b.spanHeight) {
                                    rowbase[j].ba.spanHeight = rowbase[j].b.spanHeight;
                                }
                                rowbase[j] = null;
                            }
                        }
                        ba.totalLineFeedWidth = totalLineFeedWidth;
                        y -= totalLineFeedWidth;
                        ba.y += lineFeedWidth + cellPadding2 + bottom_ - totalLineFeedWidth;
                        if (top_.isUndefined) {
                            top_ = pos_.y + totalLineFeedWidth - cellPadding2 + bottom_;
                        }
                    }
                }
            }

            private drawHLine(writer, offset, count, x, y, w, h, lw, col) {
                if (count == 2) {
                    writer.drawLine(x, y+offset, w, h, lw, col);
                    writer.drawLine(x, y+offset-2, w, h, lw, col);
                } else {
                    writer.drawLine(x, y, w, h, lw, col);
                }
            }

            private drawVLine(writer, offset, count, x, y, w, h, lw, col) {
                if (count == 2) {
                    writer.drawLine(x+offset, y, w, h, lw, col);
                    writer.drawLine(x+offset+2, y, w, h, lw, col);
                } else {
                    writer.drawLine(x, y, w, h, lw, col);
                }
            }

            private outputLine(writer, array, count, offset, y, nextLine) {
                var xbase = left_;
                y ??= array.y + offsetY_;
                for (var i = 0, l = array.length() - 1; i <= l; ++i) {
                    var h = array[i];
                    var bgColor = h.attrs.bgColor ?? bgColor_;
                    var noHLine = nextLine.isArray ? nextLine[i].rowspan : false;
                    if (!noHLine || bgColor) {
                        drawHLine(writer, offset, count, xbase, y, h.width, 0, lineWidthBase, noHLine ? bgColor : null);
                    }
                    xbase += h.width;
                }
            }

            private outputTextImpl(array, writer, xbase, ybase, totalLineFeedWidth, prevLineCount, nextLineCount) {
                var cellPadding = info_.base.table.cellPadding;
                var x = xbase;
                var l = array.length();
                var topadjust = (lineWidthBase*2) + (prevLineCount == 2 ? 1 : 0);
                var botadjust = (nextLineCount == 2 ? (lineWidthBase + 2) : 0);
                for (var i = 0; i < l; ++i) {
                    var h = array[i];
                    var bgColor = h.attrs.bgColor ?? bgColor_;
                    if (bgColor && h.width > 0) {
                        var height = h.spanHeight < totalLineFeedWidth ? totalLineFeedWidth : h.spanHeight;
                        if (!h.rowspan && !h.cowspan) {
                            writer.drawBox(
                                x + lineWidthBase,
                                ybase + totalLineFeedWidth - topadjust + lineWidthBase/4,
                                h.width - lineWidthBase * (h.colSpanCount + 1),
                                height - topadjust + botadjust,
                                0, bgColor, bgColor
                            );
                        }
                    }
                    x += h.width;
                }
                for (var i = 0; i < l; ++i) {
                    var h = array[i];
                    var halign = h.halign ?? (align_[i].align == 'c'[0] ? "center" : (align_[i].align == 'r'[0] ? "right" : "left"));
                    var isCenter = halign == "center";
                    var isRight  = halign == "right";
                    var y = h.y + offsetY_;
                    var valign = h.valign ?? valign_;
                    if (valign == "middle") {
                        if (h.totalLineFeedWidth < totalLineFeedWidth) {
                            y -= (totalLineFeedWidth - h.totalLineFeedWidth) / 2;
                        } else if (h.totalLineFeedWidth < h.spanHeight) {
                            y -= (h.spanHeight - h.totalLineFeedWidth) / 2;
                        }
                    } else if (valign == "bottom") {
                        if (h.totalLineFeedWidth < totalLineFeedWidth) {
                            y -= totalLineFeedWidth - h.totalLineFeedWidth;
                        } else if (h.totalLineFeedWidth < h.spanHeight) {
                            y -= h.spanHeight - h.totalLineFeedWidth;
                        }
                    }
                    h.lines.each { &(line)
                        var x = xbase + cellPadding;
                        var offsetX = 0;
                        if (line.totalWidth != line.width) {
                            if (isCenter) {
                                x += (h.areaWidth - line.totalWidth) / 2;
                            } else if (isRight) {
                                x += h.areaWidth - line.totalWidth;
                            }
                        }
                        line.nodes.each { &(n)
                            writer.write(n, x, y);
                            x += n.width;
                        };
                        y -= line.lineFeedWidth;
                    };
                    if (align_[i].left && !h.colspan) {
                        var diff = prevLineCount == 2 ? 1 : 0;
                        drawVLine(writer, i == 0 ? 0 : -1, align_[i].lcount, xbase,
                            ybase + totalLineFeedWidth + diff, 0, totalLineFeedWidth + diff, lineWidthBase);
                    }
                    xbase += h.width;
                    if (align_[i].right) {
                        drawVLine(writer, -2, align_[i].rcount, xbase,
                            ybase + totalLineFeedWidth, 0, totalLineFeedWidth, lineWidthBase);
                    }
                }
            }

            private outputText(writer, table, array, prevLineCount, nextLineCount, isLast) {
                var xbase = left_;
                var ybase = array.y + offsetY_;
                var totalLineFeedWidth = array.totalLineFeedWidth;
                var spanHeight = array.spanHeight;
                var height = spanHeight < totalLineFeedWidth ? totalLineFeedWidth : spanHeight;
                var checkY = ybase + totalLineFeedWidth - info_.base.table.cellPadding;

                if (writer.isColumnBreakPoint(height, checkY)) {
                    writer.setPos({ x: xbase, y: checkY });
                    writer.columnBreak();
                    var colnum = writer.getColumnNumber();
                    var cellPadding2 = info_.base.table.cellPadding * 2;
                    if (header_ && !array.isHeader) {
                        if (colnum == 0) {
                            offsetY_ = margin_.pageHeight - margin_.top - header_[0].y - header_.totalLineFeedWidth + cellPadding2;
                        } else {
                            offsetY_ = pos_.y - header_[0].y;
                        }
                        ybase = header_.y + offsetY_;
                        outputTextImpl(header_, writer, xbase, ybase, header_.totalLineFeedWidth);
                        if (header_.index >= 0) {
                            var hline0 = table.body[header_.index - 1];
                            if (hline0.isTableHLine) {
                                outputLine(writer, header_, hline0.count, 0, ybase + header_.totalLineFeedWidth, null);
                            }
                        }
                        var hline1 = table.body[header_.index + 1];
                        if (hline1.isTableHLine) {
                            outputLine(writer, header_, hline1.count, +1, ybase, null);
                            prevLineCount = hline1.count;
                        }
                    }
                    if (colnum == 0) {
                        offsetY_ = margin_.pageHeight - margin_.top - array[0].y - (header_.totalLineFeedWidth * 2) + cellPadding2;
                    } else {
                        offsetY_ = pos_.y - array[0].y - header_.totalLineFeedWidth;
                    }
                    ybase = array.y + offsetY_;
                }

                outputTextImpl(array, writer, xbase, ybase, totalLineFeedWidth, prevLineCount, nextLineCount);
                return ybase;
            }

            private outputBody(table) {
                var writer = info_.writer;
                var ybase, prevLineCount = 0;
                var l = table.body.length() - 1;
                for (var i = 0, l2 = l - 1; i <= l; ++i) {
                    var nextLine = getNextLine(table.body, i, l);
                    var ba = table.body[i];
                    var i1 = i + 1;
                    var nextLineCount = (i < l2 && table.body[i1].isTableHLine) ? table.body[i1].count : 0;
                    if (ba.isTableHLine) {
                        if (i == 0) {
                            var array = table.body[1];
                            if (array) {
                                var totalLineFeedWidth = array.totalLineFeedWidth;
                                var spanHeight = array.spanHeight;
                                var height = spanHeight < totalLineFeedWidth ? totalLineFeedWidth : spanHeight;
                                var checkY = array.y + totalLineFeedWidth + offsetY_;
                                if (writer.isColumnBreakPoint(height, checkY)) {
                                    if (writer.getPos().y >= 0) {
                                        writer.setPos({ x: -1, y: checkY });
                                        writer.columnBreak();
                                    }
                                    var colnum = writer.getColumnNumber();
                                    var cellPadding2 = info_.base.table.cellPadding * 2;
                                    if (colnum == 0) {
                                        offsetY_ = margin_.pageHeight - margin_.top - array[0].y - (header_.totalLineFeedWidth * 2) + cellPadding2;
                                    } else {
                                        offsetY_ = pos_.y - array[0].y - header_.totalLineFeedWidth;
                                    }
                                }
                                outputLine(writer, array, ba.count, 0, array.y + array.totalLineFeedWidth + offsetY_, nextLine);
                                prevLineCount = ba.count;
                            }
                        } else if (i == l) {
                            outputLine(writer, table.body[i-1], ba.count, +2, null, nextLine);
                        } else {
                            outputLine(writer, table.body[i-1], ba.count, +1, null, nextLine);
                            prevLineCount = ba.count;
                        }
                    } else {
                        ybase = outputText(writer, table, ba, prevLineCount, nextLineCount);
                        prevLineCount = 0;
                    }
                }
                return ybase;
            }

            public exec(table, tableCaptionWriter) {
                var writer = info_.writer;
                savedPos_ = writer.getPos();
                savedMargin_ = writer.getMargin();
                margin_ = writer.makeMarginSize({ cache: false });
                limitWidthDefault_ = table.limitWidth ?? limitWidthBase_;

                var fontSize = context_.font.fontSize;
                var paragraphSkipWidth = context_.page.paragraphSkipWidth;
                context_.page.paragraphSkipWidth = context_.page.lineFeedWidthRatio * fontSize;
                bottom_ = -fontSize / 2;

                writer.lineBreak(0);    // setup x & y.
                if (writer.isColumnBreakPoint(paragraphSkipWidth * 2 + info_.base.table.cellPadding * 3)) {
                    if (writer.getPos().y >= 0) {
                        writer.columnBreak();
                    }
                }
                if (table.caption) {
                    tableCaptionWriter();
                }

                pos_ = writer.getPos();

                widthlist = setupTable(table);
                makeLines(table, widthlist);
                var ybase = outputBody(table);

                context_.page.paragraphSkipWidth = paragraphSkipWidth;

                writer.setMargin(savedMargin_);
                writer.setPos({ x: -1, y: ybase });
                writer.lineBreak(paragraphSkipWidth);
                if (info_.base.resetIndentAfterNonParagraph) {
                    context_.notParagraph = info_.base.noIndentTopOfParagraph;
                }
            }

        }

    } # namespace ProcessDoc

} # namespace Typesetting
